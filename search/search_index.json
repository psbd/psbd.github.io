{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Plan The plan is to use this documentation to put the technical interivew prepartion materials. We plan to update it at least once everyday. We will be writing the text in the first person view, meaning we will be using the word We to present our thoughts. At the same time, we will be using the word you to refer the readers of the text. As of now, we are the you ! Getting Started for (int i = 0; i < 24; i+=1) { int example = 4; System.out.print(example); }","title":"The Plan"},{"location":"#the-plan","text":"The plan is to use this documentation to put the technical interivew prepartion materials. We plan to update it at least once everyday. We will be writing the text in the first person view, meaning we will be using the word We to present our thoughts. At the same time, we will be using the word you to refer the readers of the text. As of now, we are the you !","title":"The Plan"},{"location":"#getting-started","text":"for (int i = 0; i < 24; i+=1) { int example = 4; System.out.print(example); }","title":"Getting Started"},{"location":"concepts/dp/","text":"Dynamic Programming keywords: enumeration, optimal substructure, overlapping subproblems, state transition equations Based on our understanding, Dynamic Programming (DP) problems are the most asked ones in the technical interivews by the top tech companies. Thus, we have started our interview preparation journey from the Dynamic Programming concepts. Generally, DP is a concept used for optimization problems (OP). Well, what are OPs?: Simply presenting, they are the problems that seek to find either maximum or minimum possible value. For example, given an array of numbers, what is the maximum possible length of the increasing subsequences that can be created from it? Example: [1,9, 2, 7, 3, 5]. Out of many possible subsequences (eg. 1, 3, 5), the longest increasing subsequence is [1,2,3,5]. If you noticed the last sentence we used out of many possible... , meaning the first though process to solving any DP problem is to find all the possible breakdowns of the problem. For the given problem, we are trying to find the longest increasing subseqeuence, thus the starting thought process could be to look at all the possible subsequences. Therefore, alongwith optimization problems, DP can be equally useful for other classes of problems where we need to enumerate the possible solutions and pick the subset from enumerations. Well, we think the intro was already too long to get you bored reading this document. So, let's dive into the actual useful content . Solving DP problems boils down to two main aspects of the problem. First, finding a optimal substructure , and second, finding overlapping subproblems . What are these fancy terms? Let's look at them in a little more details in the subsections below: Optimal Substructure To understand optimal substructure, let's first understand substructure. So, let's get out of the jargon of DP: let's say, we want to find the wealthiest person in the world, and also let's say that every city in the world compiles a list of people living in the city and their wealth. So, to find the wealthiest person on the earth, one way could be to collect all these lists of people from every city to create a superlong list of billions of people, and then look for the wealthiest person from the list. The other approach would be to divide the task into several steps ( subproblems ). For example, let's first find the wealthiest person in every city. Then, at country level, let's compile a list of all these city-based weltiest persons, and then find the wealthies person in every country. Then, let's compile another list of these country-level wealthiest people at the world-level, and find the wealthiest person in the world! Well, this example is not a DP problem, but we hope you get some idea on substructure. There are two key concepts in these substructures. 1. The problem has to be broken down into levels 2. The problem defintion at every level should remain the same!!! (the most important theory!) Now coming back to the optimal substructure, the idea here is to extend the concept of same problem definition at every level. So, (generally, an optimization) problem is said to have an optimal substructure property if it can be broken down into subproblems and the final solution of the problem can be derived from the solution of these subproblems (also note that: these subproblems could derive their solutions from their own subproblems, and so on!). In our example above, the worldwide problem was solved by solving the same problem (finding the wealthiest) for countries, and the same problem for a country was solved by solving the same problem for cities in the country. Thus, it exibits the optimal substructure property. Overlapping subproblems Looking at our example above, one thing we can say is that the optimal substructure is not only true for DP problems (how could finding the wealthiest person in the world be a Dynamic Programming problem!). What makes these problems with the optimal substructures, the DP problems, is their characterstic of Overlapping subproblem . So, what exactly is it? For this, let's look at another example:","title":"Dynamic Programming"},{"location":"concepts/dp/#dynamic-programming","text":"keywords: enumeration, optimal substructure, overlapping subproblems, state transition equations Based on our understanding, Dynamic Programming (DP) problems are the most asked ones in the technical interivews by the top tech companies. Thus, we have started our interview preparation journey from the Dynamic Programming concepts. Generally, DP is a concept used for optimization problems (OP). Well, what are OPs?: Simply presenting, they are the problems that seek to find either maximum or minimum possible value. For example, given an array of numbers, what is the maximum possible length of the increasing subsequences that can be created from it? Example: [1,9, 2, 7, 3, 5]. Out of many possible subsequences (eg. 1, 3, 5), the longest increasing subsequence is [1,2,3,5]. If you noticed the last sentence we used out of many possible... , meaning the first though process to solving any DP problem is to find all the possible breakdowns of the problem. For the given problem, we are trying to find the longest increasing subseqeuence, thus the starting thought process could be to look at all the possible subsequences. Therefore, alongwith optimization problems, DP can be equally useful for other classes of problems where we need to enumerate the possible solutions and pick the subset from enumerations. Well, we think the intro was already too long to get you bored reading this document. So, let's dive into the actual useful content . Solving DP problems boils down to two main aspects of the problem. First, finding a optimal substructure , and second, finding overlapping subproblems . What are these fancy terms? Let's look at them in a little more details in the subsections below:","title":"Dynamic Programming"},{"location":"concepts/dp/#optimal-substructure","text":"To understand optimal substructure, let's first understand substructure. So, let's get out of the jargon of DP: let's say, we want to find the wealthiest person in the world, and also let's say that every city in the world compiles a list of people living in the city and their wealth. So, to find the wealthiest person on the earth, one way could be to collect all these lists of people from every city to create a superlong list of billions of people, and then look for the wealthiest person from the list. The other approach would be to divide the task into several steps ( subproblems ). For example, let's first find the wealthiest person in every city. Then, at country level, let's compile a list of all these city-based weltiest persons, and then find the wealthies person in every country. Then, let's compile another list of these country-level wealthiest people at the world-level, and find the wealthiest person in the world! Well, this example is not a DP problem, but we hope you get some idea on substructure. There are two key concepts in these substructures. 1. The problem has to be broken down into levels 2. The problem defintion at every level should remain the same!!! (the most important theory!) Now coming back to the optimal substructure, the idea here is to extend the concept of same problem definition at every level. So, (generally, an optimization) problem is said to have an optimal substructure property if it can be broken down into subproblems and the final solution of the problem can be derived from the solution of these subproblems (also note that: these subproblems could derive their solutions from their own subproblems, and so on!). In our example above, the worldwide problem was solved by solving the same problem (finding the wealthiest) for countries, and the same problem for a country was solved by solving the same problem for cities in the country. Thus, it exibits the optimal substructure property.","title":"Optimal Substructure"},{"location":"concepts/dp/#overlapping-subproblems","text":"Looking at our example above, one thing we can say is that the optimal substructure is not only true for DP problems (how could finding the wealthiest person in the world be a Dynamic Programming problem!). What makes these problems with the optimal substructures, the DP problems, is their characterstic of Overlapping subproblem . So, what exactly is it? For this, let's look at another example:","title":"Overlapping subproblems"}]}