{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Plan The plan is to use this documentation to put the technical interivew prepartion materials. We plan to update it at least once everyday. We will be writing the text in the first person view, meaning we will be using the word We to present our thoughts. At the same time, we will be using the word you to refer the readers of the text. As of now, we are the you ! Getting Started for (int i = 0; i < 24; i+=1) { int example = 4; System.out.print(example); }","title":"The Plan"},{"location":"#the-plan","text":"The plan is to use this documentation to put the technical interivew prepartion materials. We plan to update it at least once everyday. We will be writing the text in the first person view, meaning we will be using the word We to present our thoughts. At the same time, we will be using the word you to refer the readers of the text. As of now, we are the you !","title":"The Plan"},{"location":"#getting-started","text":"for (int i = 0; i < 24; i+=1) { int example = 4; System.out.print(example); }","title":"Getting Started"},{"location":"concepts/dp/","text":"Dynamic Programming keywords: enumeration, optimal substructure, overlapping subproblems, state transition equations confusions: top-down approach vs bottom-up approach ==> dynamic programming vs memoization Based on our understanding, Dynamic Programming (DP) problems are the most asked ones in the technical interivews by the top tech companies. Thus, we have started our interview preparation journey from the Dynamic Programming concepts. Generally, DP is a concept used for optimization problems (OP). Well, what are OPs?: Simply presenting, they are the problems that seek to find either maximum or minimum possible value. For example, given an array of numbers, what is the maximum possible length of the increasing subsequences that can be created from it? Example: [1,9, 2, 7, 3, 5]. Out of many possible subsequences (eg. 1, 3, 5), the longest increasing subsequence is [1,2,3,5]. If you noticed the last sentence we used out of many possible... , meaning the first though process to solving any DP problem is to find all the possible breakdowns of the problem. For the given problem, we are trying to find the longest increasing subseqeuence, thus the starting thought process could be to look at all the possible subsequences. Therefore, alongwith optimization problems, DP can be equally useful for other classes of problems where we need to enumerate the possible solutions and pick the subset from enumerations. Well, we think the intro was already too long to get you bored reading this document. So, let's dive into the actual useful content . Solving DP problems boils down to two main aspects of the problem. First, finding a optimal substructure , and second, finding overlapping subproblems . What are these fancy terms? Let's look at them in a little more details in the subsections below: Optimal Substructure To understand optimal substructure, let's first understand substructure. So, let's get out of the jargon of DP: let's say, we want to find the wealthiest person in the world, and also let's say that every city in the world compiles a list of people living in the city and their wealth. So, to find the wealthiest person on the earth, one way could be to collect all these lists of people from every city to create a superlong list of billions of people, and then look for the wealthiest person from the list. The other approach would be to divide the task into several steps ( subproblems ). For example, let's first find the wealthiest person in every city. Then, at country level, let's compile a list of all these city-based weltiest persons, and then find the wealthies person in every country. Then, let's compile another list of these country-level wealthiest people at the world-level, and find the wealthiest person in the world! Well, this example is not a DP problem, but we hope you get some idea on substructure. There are two key concepts in these substructures. 1. The problem has to be broken down into levels 2. The problem defintion at every level should remain the same!!! (the most important theory!) Now coming back to the optimal substructure, the idea here is to extend the concept of same problem definition at every level. So, (generally, an optimization) problem is said to have an optimal substructure property if it can be broken down into subproblems and the final solution of the problem can be derived from the solution of these subproblems (also note that: these subproblems could derive their solutions from their own subproblems, and so on!). In our example above, the worldwide problem was solved by solving the same problem (finding the wealthiest) for countries, and the same problem for a country was solved by solving the same problem for cities in the country. Thus, it exibits the optimal substructure property. Overlapping subproblems Looking at our example above, one thing we can say is that the optimal substructure is not only true for DP problems (how could finding the wealthiest person in the world be a Dynamic Programming problem!). What makes these problems with the optimal substructures, closer to the DP problems, is their characterstic of Overlapping subproblem . So, what exactly is it? For this, let's extend the above problem of finding the wealthiest person in the world with one unrealistic assumption. Let's say, there are many cities in the world that belong to multiple countries (which is not possible in this divided world, but in our idle world, let's say this is true!). For example, let's say there are three countries A, B, and C . Country A has cities x, y , and z; B has cities y ,p,q; and C has cities x , q ,r,s! Also, let's present the above solution from a different perspective (people call it top-down approach, which we will discuss in more details later!). So, let's say, country A first finds its wealthiest person. For this, it asks its cities x, y , and z to do the same. The cities look at their list and find their wealthiest person and report to the country. Now country B does the same asking its cities y ,p,q. The cities look at their lists and find their wealthies person. City y , although it calculated its wealthiest person already for country A, it does the same process of looking throught the same list again for country B. Similarly, x , and q of country C again repeat the process that they already did for their other countries A, and B respectively. I think you are seeing some pattern here, same subproblem (city) has repeated for multiple countries. So, instead of calculating the wealthiest person for a new country again, these cities could be used their previous calculations that they did for the other country. This is the main power of DP problems. So, the main idea of overlapping subproblem is as follows: 1. Same lower subproblem appears in multiple subproblems. DP Problem solving pipeline Always try to numericalize the given problem. For example, if the problem involves an array or string, try to present the problem in terms of the index of the element in the array or the index of character in the string. Further, in some cases, even if the problem itself is numerical, rephrasing the problem with different numericalization might render the problem being lot more easy to solve. Next try to reframe the given problem in terms of similar smaller subproblems to generate the state transition equations. The most important practice to think in this way is to try out a lot of recursive problems. While thinking the solution of the problem as the development from the subproblems that have the same definition but involving subparts of the given input, the best practice would be to believe that we already have answers to these subproblems. Then based on the problem statement, come up with the base cases that have the direct values and do not need to be solved recursively. Be aware of the subproblems that are recurring and find ways to store these values so that any future subproblem that relies on the answer of the previous subproblems can directly use them. We will look into a few problems below and disect them in an attempt to follow through the above DP problem solving pipeline just to have better understanding of it. Let's look at the following string/array based DP problems from Leetcode: 72. Edit Distance 1143. Longest Common Subsequence 300. Longest Increasing Subsequence Starting with 300., the first thing in solving a problem is to read it carefully enough such that we do not miss any detail in the question. Let me rewrite the problem while reading it slowly: We are given an unsorted array of integers. We need to find the length of the longest increasing subsequence. The first thing is to figure out that the question is asking for the longest something, making DP one of the viable approaches to solve the problem. Following the first step of the pipeline, let's first try to numericalize the problem. One approach would be to descibe the given array with two numbers, the indices of the first and the last elements of the array. This way, we can look at the subproblems being the subarrays represented with the indices between the indices of the original problem. I am sure you must have lost my explanation here. So, let's look at an example. If the given array is [10,9,2,5,3,7,101,18], we numericalize the problem as follows: find the length of longest increasing subsequence for the given array between the indices 0 and 7 (inclusive). With this as the main problem, our subproblems might be to find the same thing (length of the longest subsequence for the given array) between indices 1 and 3 or between 2 and 5. Similarly, the subproblems for the one between indices 1 and 3 include the indices betwee 1 and 2 or between 2 and 3 or between 2 and 2, etc. One thing you might have noticed while defining the problem with two indices, we can see that the subproblems are being defined with movements on both the ends. Obviously, a problem with movement on the both ends will be difficult to solve, so let's try to renumericalize the problem with a single movable component, if possible. Let's say, we fix the first index at 0 for every possible subproblems, and renumericalize the problem as finding the longest increasing subsequence for the array upto the index 7. Notice, that I am using upto the index 7, rather than saying ending at index 7. We can compute the value of LIS using the definition as ending at index 7 as well, but wanted to let you know that different defintion will yield different approaches later in the pipeline, and if we happen to mix them up, we are not going to get the correct answer, so while numericalizing the problem, pay extra attention not to miss out the minute details that you have assumed. Now, the subproblems would include the longest length of LIS (notice that I am using the same definition of problem for the subproblems!) upto the index 6, upto the index 5, etc. People like to define these indices in the problems as pointers (which are just a fancy way of saying the same thing). Now, let's try to rephrase our problem as a development from the subproblems. Like we said above, while looking for the solution for the problem, let's not try to think about solving subproblems from their own subproblems at this point in time. But rather let's believe that there's already solutions to every subproblem of the problem. Once we are able to define the solution completely with the help of subproblems, same solution will apply to the subproblems of each subproblem, and so on. I know it is difficult to understand what I am trying to say here, so let's try to apply this concept for the above question. To find the longest length of LIS for the array upto the index 7, let's believe that we already have LIS for the arrays upto any index before 7. Now, with this assumption of longest length of LIS already been computed for lower indices, how can we use these integer values of LISes to find longest length of LIS upto index 7? To answer this question, let's look at the fundamental definition of Increasing Subsequence before dealing with the longest one. For this, always think in linear steps, because that's how comuters execute your code, right? So, for example, to create a subsequence of length 4, we start with the first element of the sequence. Next, to put the second element to the Increasing sequence, we put this second item to the sequence, only if it is larger than the first one. Then for the third element, we put it to the sequence only if it is larger than the second element, and so on. So, with the length of LISes upto any of the array indices before 7 already computed, we would be able to extend the length of any of these subsequences, only if the element in index 7 is larger than the element at the respective index, right? So, let's say we have our longest length of LIS for index 1, 2, and 3 as p, q, and r. So, if we are trying to find LIS of l ... States and Choices Read every question very carefully. Every question will have states. For example, in case of stock buy and sell problem, we are given the prices of stocks on each day in form of an array and our goal is to maximize the profit that we can get. One thing we have to make sure while buying and selling the stocks is that we are not allowed to have hold of any stock before buying a new one. If we have to buy a new stock, we need to check if we have already owned a stock, if so, we need to first sell it, and only than we can buy a new one. Solving this problem boils down to states, and choices. So, each day we have an option to buy, sell, or remain idle. Meaning, one of our states could be the day where we currently are on, right? And as you might have guessed, our choices in each day is to buy, sell, or remain idle. Now, have we completely defined the problem in terms of states and choices. I think not, we still need to handle the requirement that we can only own a single stock at any instance. Meaning, our choices are constrained. So, to handle the constaints in the choices, we need to define it in terms of other state(s). And I generally call these states as the induced state, the other states that we define directly from the question, I call them direct states. Also, we need to make sure that our DP solution handles every possible states in the state transition equations. That's for now! We will get into the details of the solution of the stock problems later.","title":"Dynamic Programming"},{"location":"concepts/dp/#dynamic-programming","text":"keywords: enumeration, optimal substructure, overlapping subproblems, state transition equations confusions: top-down approach vs bottom-up approach ==> dynamic programming vs memoization Based on our understanding, Dynamic Programming (DP) problems are the most asked ones in the technical interivews by the top tech companies. Thus, we have started our interview preparation journey from the Dynamic Programming concepts. Generally, DP is a concept used for optimization problems (OP). Well, what are OPs?: Simply presenting, they are the problems that seek to find either maximum or minimum possible value. For example, given an array of numbers, what is the maximum possible length of the increasing subsequences that can be created from it? Example: [1,9, 2, 7, 3, 5]. Out of many possible subsequences (eg. 1, 3, 5), the longest increasing subsequence is [1,2,3,5]. If you noticed the last sentence we used out of many possible... , meaning the first though process to solving any DP problem is to find all the possible breakdowns of the problem. For the given problem, we are trying to find the longest increasing subseqeuence, thus the starting thought process could be to look at all the possible subsequences. Therefore, alongwith optimization problems, DP can be equally useful for other classes of problems where we need to enumerate the possible solutions and pick the subset from enumerations. Well, we think the intro was already too long to get you bored reading this document. So, let's dive into the actual useful content . Solving DP problems boils down to two main aspects of the problem. First, finding a optimal substructure , and second, finding overlapping subproblems . What are these fancy terms? Let's look at them in a little more details in the subsections below:","title":"Dynamic Programming"},{"location":"concepts/dp/#optimal-substructure","text":"To understand optimal substructure, let's first understand substructure. So, let's get out of the jargon of DP: let's say, we want to find the wealthiest person in the world, and also let's say that every city in the world compiles a list of people living in the city and their wealth. So, to find the wealthiest person on the earth, one way could be to collect all these lists of people from every city to create a superlong list of billions of people, and then look for the wealthiest person from the list. The other approach would be to divide the task into several steps ( subproblems ). For example, let's first find the wealthiest person in every city. Then, at country level, let's compile a list of all these city-based weltiest persons, and then find the wealthies person in every country. Then, let's compile another list of these country-level wealthiest people at the world-level, and find the wealthiest person in the world! Well, this example is not a DP problem, but we hope you get some idea on substructure. There are two key concepts in these substructures. 1. The problem has to be broken down into levels 2. The problem defintion at every level should remain the same!!! (the most important theory!) Now coming back to the optimal substructure, the idea here is to extend the concept of same problem definition at every level. So, (generally, an optimization) problem is said to have an optimal substructure property if it can be broken down into subproblems and the final solution of the problem can be derived from the solution of these subproblems (also note that: these subproblems could derive their solutions from their own subproblems, and so on!). In our example above, the worldwide problem was solved by solving the same problem (finding the wealthiest) for countries, and the same problem for a country was solved by solving the same problem for cities in the country. Thus, it exibits the optimal substructure property.","title":"Optimal Substructure"},{"location":"concepts/dp/#overlapping-subproblems","text":"Looking at our example above, one thing we can say is that the optimal substructure is not only true for DP problems (how could finding the wealthiest person in the world be a Dynamic Programming problem!). What makes these problems with the optimal substructures, closer to the DP problems, is their characterstic of Overlapping subproblem . So, what exactly is it? For this, let's extend the above problem of finding the wealthiest person in the world with one unrealistic assumption. Let's say, there are many cities in the world that belong to multiple countries (which is not possible in this divided world, but in our idle world, let's say this is true!). For example, let's say there are three countries A, B, and C . Country A has cities x, y , and z; B has cities y ,p,q; and C has cities x , q ,r,s! Also, let's present the above solution from a different perspective (people call it top-down approach, which we will discuss in more details later!). So, let's say, country A first finds its wealthiest person. For this, it asks its cities x, y , and z to do the same. The cities look at their list and find their wealthiest person and report to the country. Now country B does the same asking its cities y ,p,q. The cities look at their lists and find their wealthies person. City y , although it calculated its wealthiest person already for country A, it does the same process of looking throught the same list again for country B. Similarly, x , and q of country C again repeat the process that they already did for their other countries A, and B respectively. I think you are seeing some pattern here, same subproblem (city) has repeated for multiple countries. So, instead of calculating the wealthiest person for a new country again, these cities could be used their previous calculations that they did for the other country. This is the main power of DP problems. So, the main idea of overlapping subproblem is as follows: 1. Same lower subproblem appears in multiple subproblems.","title":"Overlapping subproblems"},{"location":"concepts/dp/#dp-problem-solving-pipeline","text":"Always try to numericalize the given problem. For example, if the problem involves an array or string, try to present the problem in terms of the index of the element in the array or the index of character in the string. Further, in some cases, even if the problem itself is numerical, rephrasing the problem with different numericalization might render the problem being lot more easy to solve. Next try to reframe the given problem in terms of similar smaller subproblems to generate the state transition equations. The most important practice to think in this way is to try out a lot of recursive problems. While thinking the solution of the problem as the development from the subproblems that have the same definition but involving subparts of the given input, the best practice would be to believe that we already have answers to these subproblems. Then based on the problem statement, come up with the base cases that have the direct values and do not need to be solved recursively. Be aware of the subproblems that are recurring and find ways to store these values so that any future subproblem that relies on the answer of the previous subproblems can directly use them. We will look into a few problems below and disect them in an attempt to follow through the above DP problem solving pipeline just to have better understanding of it. Let's look at the following string/array based DP problems from Leetcode: 72. Edit Distance 1143. Longest Common Subsequence 300. Longest Increasing Subsequence Starting with 300., the first thing in solving a problem is to read it carefully enough such that we do not miss any detail in the question. Let me rewrite the problem while reading it slowly: We are given an unsorted array of integers. We need to find the length of the longest increasing subsequence. The first thing is to figure out that the question is asking for the longest something, making DP one of the viable approaches to solve the problem. Following the first step of the pipeline, let's first try to numericalize the problem. One approach would be to descibe the given array with two numbers, the indices of the first and the last elements of the array. This way, we can look at the subproblems being the subarrays represented with the indices between the indices of the original problem. I am sure you must have lost my explanation here. So, let's look at an example. If the given array is [10,9,2,5,3,7,101,18], we numericalize the problem as follows: find the length of longest increasing subsequence for the given array between the indices 0 and 7 (inclusive). With this as the main problem, our subproblems might be to find the same thing (length of the longest subsequence for the given array) between indices 1 and 3 or between 2 and 5. Similarly, the subproblems for the one between indices 1 and 3 include the indices betwee 1 and 2 or between 2 and 3 or between 2 and 2, etc. One thing you might have noticed while defining the problem with two indices, we can see that the subproblems are being defined with movements on both the ends. Obviously, a problem with movement on the both ends will be difficult to solve, so let's try to renumericalize the problem with a single movable component, if possible. Let's say, we fix the first index at 0 for every possible subproblems, and renumericalize the problem as finding the longest increasing subsequence for the array upto the index 7. Notice, that I am using upto the index 7, rather than saying ending at index 7. We can compute the value of LIS using the definition as ending at index 7 as well, but wanted to let you know that different defintion will yield different approaches later in the pipeline, and if we happen to mix them up, we are not going to get the correct answer, so while numericalizing the problem, pay extra attention not to miss out the minute details that you have assumed. Now, the subproblems would include the longest length of LIS (notice that I am using the same definition of problem for the subproblems!) upto the index 6, upto the index 5, etc. People like to define these indices in the problems as pointers (which are just a fancy way of saying the same thing). Now, let's try to rephrase our problem as a development from the subproblems. Like we said above, while looking for the solution for the problem, let's not try to think about solving subproblems from their own subproblems at this point in time. But rather let's believe that there's already solutions to every subproblem of the problem. Once we are able to define the solution completely with the help of subproblems, same solution will apply to the subproblems of each subproblem, and so on. I know it is difficult to understand what I am trying to say here, so let's try to apply this concept for the above question. To find the longest length of LIS for the array upto the index 7, let's believe that we already have LIS for the arrays upto any index before 7. Now, with this assumption of longest length of LIS already been computed for lower indices, how can we use these integer values of LISes to find longest length of LIS upto index 7? To answer this question, let's look at the fundamental definition of Increasing Subsequence before dealing with the longest one. For this, always think in linear steps, because that's how comuters execute your code, right? So, for example, to create a subsequence of length 4, we start with the first element of the sequence. Next, to put the second element to the Increasing sequence, we put this second item to the sequence, only if it is larger than the first one. Then for the third element, we put it to the sequence only if it is larger than the second element, and so on. So, with the length of LISes upto any of the array indices before 7 already computed, we would be able to extend the length of any of these subsequences, only if the element in index 7 is larger than the element at the respective index, right? So, let's say we have our longest length of LIS for index 1, 2, and 3 as p, q, and r. So, if we are trying to find LIS of l ...","title":"DP Problem solving pipeline"},{"location":"concepts/dp/#states-and-choices","text":"Read every question very carefully. Every question will have states. For example, in case of stock buy and sell problem, we are given the prices of stocks on each day in form of an array and our goal is to maximize the profit that we can get. One thing we have to make sure while buying and selling the stocks is that we are not allowed to have hold of any stock before buying a new one. If we have to buy a new stock, we need to check if we have already owned a stock, if so, we need to first sell it, and only than we can buy a new one. Solving this problem boils down to states, and choices. So, each day we have an option to buy, sell, or remain idle. Meaning, one of our states could be the day where we currently are on, right? And as you might have guessed, our choices in each day is to buy, sell, or remain idle. Now, have we completely defined the problem in terms of states and choices. I think not, we still need to handle the requirement that we can only own a single stock at any instance. Meaning, our choices are constrained. So, to handle the constaints in the choices, we need to define it in terms of other state(s). And I generally call these states as the induced state, the other states that we define directly from the question, I call them direct states. Also, we need to make sure that our DP solution handles every possible states in the state transition equations. That's for now! We will get into the details of the solution of the stock problems later.","title":"States and Choices"},{"location":"concepts/dpAdd/","text":"Moving forward vs moving backward in DP problems Today while looking at the keyboard with leetcode 651. 4 keys keyboard problem, we were having some hard time to relate this problem with any other DP problems, because the solution mechanism is a bit tricky and different. So, we will be discussing about these mechanisms in details in this article. Every DP problem starts with numericalization, and then defining the states. Based on these states, we come up with the state transition equations. So far, in our problems, we defined a final state that provides the answer to the problem at hand, then we looked at the subproblems that we solved in a top-down approach. In the bottom-up approach, we started with the base cases (the smallest subproblems), and moved forward to eventually reach the final state. So, the blueprint for solving these problems was: for top-down approach, we started with the state for the final problem definition and moved recursively downwards into the subproblems, until we reached the base case from which we returned back. Similarly, in the bottom-up approach of the problems, we started with the base cases and slowly built more complex problems from them and moved towards the final problem. The case with the 4 Keys keyboard is a bit different, because when we define (number of keystrokes (either remaining or pressed), number of items in the screen, number of items in the clipboard), we do not really know the final state we will be in. So, the above approaches are not gonna work. So, for the top down approach, instead of moving from the state definition of the final problem, we need to start from the state definition of the initial state which is known to us (number of keystrokes (either remaining or pressed)=n or 0, items in screen = 0, items in clipboard = 0).","title":"Moving forward vs moving backward in DP problems"},{"location":"concepts/dpAdd/#moving-forward-vs-moving-backward-in-dp-problems","text":"Today while looking at the keyboard with leetcode 651. 4 keys keyboard problem, we were having some hard time to relate this problem with any other DP problems, because the solution mechanism is a bit tricky and different. So, we will be discussing about these mechanisms in details in this article. Every DP problem starts with numericalization, and then defining the states. Based on these states, we come up with the state transition equations. So far, in our problems, we defined a final state that provides the answer to the problem at hand, then we looked at the subproblems that we solved in a top-down approach. In the bottom-up approach, we started with the base cases (the smallest subproblems), and moved forward to eventually reach the final state. So, the blueprint for solving these problems was: for top-down approach, we started with the state for the final problem definition and moved recursively downwards into the subproblems, until we reached the base case from which we returned back. Similarly, in the bottom-up approach of the problems, we started with the base cases and slowly built more complex problems from them and moved towards the final problem. The case with the 4 Keys keyboard is a bit different, because when we define (number of keystrokes (either remaining or pressed), number of items in the screen, number of items in the clipboard), we do not really know the final state we will be in. So, the above approaches are not gonna work. So, for the top down approach, instead of moving from the state definition of the final problem, we need to start from the state definition of the initial state which is known to us (number of keystrokes (either remaining or pressed)=n or 0, items in screen = 0, items in clipboard = 0).","title":"Moving forward vs moving backward in DP problems"}]}