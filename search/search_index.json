{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Plan The plan is to use this documentation to put the technical interivew prepartion materials. We plan to update it at least once everyday. We will be writing the text in the first person view, meaning we will be using the word We to present our thoughts. At the same time, we will be using the word you to refer the readers of the text. As of now, we are the you ! Getting Started for (int i = 0; i < 24; i+=1) { int example = 4; System.out.print(example); }","title":"The Plan"},{"location":"#the-plan","text":"The plan is to use this documentation to put the technical interivew prepartion materials. We plan to update it at least once everyday. We will be writing the text in the first person view, meaning we will be using the word We to present our thoughts. At the same time, we will be using the word you to refer the readers of the text. As of now, we are the you !","title":"The Plan"},{"location":"#getting-started","text":"for (int i = 0; i < 24; i+=1) { int example = 4; System.out.print(example); }","title":"Getting Started"},{"location":"concepts/dp/","text":"Dynamic Programming keywords: enumeration, optimal substructure, overlapping subproblems, state transition equations confusions: top-down approach vs bottom-up approach ==> dynamic programming vs memoization Based on our understanding, Dynamic Programming (DP) problems are the most asked ones in the technical interivews by the top tech companies. Thus, we have started our interview preparation journey from the Dynamic Programming concepts. Generally, DP is a concept used for optimization problems (OP). Well, what are OPs?: Simply presenting, they are the problems that seek to find either maximum or minimum possible value. For example, given an array of numbers, what is the maximum possible length of the increasing subsequences that can be created from it? Example: [1,9, 2, 7, 3, 5]. Out of many possible subsequences (eg. 1, 3, 5), the longest increasing subsequence is [1,2,3,5]. If you noticed the last sentence we used out of many possible... , meaning the first though process to solving any DP problem is to find all the possible breakdowns of the problem. For the given problem, we are trying to find the longest increasing subseqeuence, thus the starting thought process could be to look at all the possible subsequences. Therefore, alongwith optimization problems, DP can be equally useful for other classes of problems where we need to enumerate the possible solutions and pick the subset from enumerations. Well, we think the intro was already too long to get you bored reading this document. So, let's dive into the actual useful content . Solving DP problems boils down to two main aspects of the problem. First, finding a optimal substructure , and second, finding overlapping subproblems . What are these fancy terms? Let's look at them in a little more details in the subsections below: Optimal Substructure To understand optimal substructure, let's first understand substructure. So, let's get out of the jargon of DP: let's say, we want to find the wealthiest person in the world, and also let's say that every city in the world compiles a list of people living in the city and their wealth. So, to find the wealthiest person on the earth, one way could be to collect all these lists of people from every city to create a superlong list of billions of people, and then look for the wealthiest person from the list. The other approach would be to divide the task into several steps ( subproblems ). For example, let's first find the wealthiest person in every city. Then, at country level, let's compile a list of all these city-based weltiest persons, and then find the wealthies person in every country. Then, let's compile another list of these country-level wealthiest people at the world-level, and find the wealthiest person in the world! Well, this example is not a DP problem, but we hope you get some idea on substructure. There are two key concepts in these substructures. 1. The problem has to be broken down into levels 2. The problem defintion at every level should remain the same!!! (the most important theory!) Now coming back to the optimal substructure, the idea here is to extend the concept of same problem definition at every level. So, (generally, an optimization) problem is said to have an optimal substructure property if it can be broken down into subproblems and the final solution of the problem can be derived from the solution of these subproblems (also note that: these subproblems could derive their solutions from their own subproblems, and so on!). In our example above, the worldwide problem was solved by solving the same problem (finding the wealthiest) for countries, and the same problem for a country was solved by solving the same problem for cities in the country. Thus, it exibits the optimal substructure property. Overlapping subproblems Looking at our example above, one thing we can say is that the optimal substructure is not only true for DP problems (how could finding the wealthiest person in the world be a Dynamic Programming problem!). What makes these problems with the optimal substructures, closer to the DP problems, is their characterstic of Overlapping subproblem . So, what exactly is it? For this, let's extend the above problem of finding the wealthiest person in the world with one unrealistic assumption. Let's say, there are many cities in the world that belong to multiple countries (which is not possible in this divided world, but in our idle world, let's say this is true!). For example, let's say there are three countries A, B, and C . Country A has cities x, y , and z; B has cities y ,p,q; and C has cities x , q ,r,s! Also, let's present the above solution from a different perspective (people call it top-down approach, which we will discuss in more details later!). So, let's say, country A first finds its wealthiest person. For this, it asks its cities x, y , and z to do the same. The cities look at their list and find their wealthiest person and report to the country. Now country B does the same asking its cities y ,p,q. The cities look at their lists and find their wealthies person. City y , although it calculated its wealthiest person already for country A, it does the same process of looking throught the same list again for country B. Similarly, x , and q of country C again repeat the process that they already did for their other countries A, and B respectively. I think you are seeing some pattern here, same subproblem (city) has repeated for multiple countries. So, instead of calculating the wealthiest person for a new country again, these cities could be used their previous calculations that they did for the other country. This is the main power of DP problems. So, the main idea of overlapping subproblem is as follows: 1. Same lower subproblem appears in multiple subproblems. DP Problem solving pipeline Always try to numericalize the given problem. For example, if the problem involves an array or string, try to present the problem in terms of the index of the element in the array or the index of character in the string. Further, in some cases, even if the problem itself is numerical, rephrasing the problem with different numericalization might render the problem being lot more easy to solve. Next try to reframe the given problem in terms of similar smaller subproblems to generate the state transition equations. The most important practice to think in this way is to try out a lot of recursive problems. Then based on the problem statement, come up with the base cases that have the direct values and do not need to be solved recursively. Be aware of the subproblems that are recurring and find ways to store these values so that any future subproblem that relies on the answer of the previous subproblems can directly use them. We will look into a few problems below and disect them in an attempt to follow through the above DP problem solving pipeline just to have better understanding of it. Let's look at the following string/array based DP problems from Leetcode: 72. Edit Distance 1143. Longest Common Subsequence 300. Longest Increasing Subsequence Starting with 300., the first thing in solving a problem is to read it carefully enough such that we do not miss any detail in the question. Let me rewrite the problem while reading it slowly: We are given an unsorted array of integers. We need to find the length of the longest increasing subsequence. The first thing is to figure out that the question is asking for the longest something, making DP one of the viable approaches to solve the problem. Following the first step of the pipeline, let's first try to numericalize the problem. One approach would be to descibe the given array with two numbers, the indices of the first and the last elements of the array. This way, we can look at the subproblems being the subarrays represented with the indices between the indices of the original problem. I am sure you must have lost my explanation here. So, let's look at an example. If the given array is [10,9,2,5,3,7,101,18], we numericalize the problem as follows: find the length of longest increasing subsequence for the given array between the indices 0 and 7 (inclusive). With this as the main problem, our subproblems might be to find the same thing (length of the longest subsequence for the given array) between indices 1 and 3 or between 2 and 5. Similarly, the subproblems for the one between indices 1 and 3 include the indices betwee 1 and 2 or between 2 and 3 or between 2 and 2, etc. One thing you might have noticed while defining the problem with two indices, we can see that the subproblems are being defined with movements on both the ends. Obviously, a problem with movement on the both ends will be difficult to solve, so let's try to renumericalize the problem with a single movable component. Let's say, we fix the first index at 0 for every possible subproblems, and renumericalize the problem as finding the longest increasing subsequence for the array ending at the index 7. Now, the subproblems would include that ending at index 6, index 5, etc. People like to define these indices in the problems as pointers (which are just a fancy way of saying the same thing).","title":"Dynamic Programming"},{"location":"concepts/dp/#dynamic-programming","text":"keywords: enumeration, optimal substructure, overlapping subproblems, state transition equations confusions: top-down approach vs bottom-up approach ==> dynamic programming vs memoization Based on our understanding, Dynamic Programming (DP) problems are the most asked ones in the technical interivews by the top tech companies. Thus, we have started our interview preparation journey from the Dynamic Programming concepts. Generally, DP is a concept used for optimization problems (OP). Well, what are OPs?: Simply presenting, they are the problems that seek to find either maximum or minimum possible value. For example, given an array of numbers, what is the maximum possible length of the increasing subsequences that can be created from it? Example: [1,9, 2, 7, 3, 5]. Out of many possible subsequences (eg. 1, 3, 5), the longest increasing subsequence is [1,2,3,5]. If you noticed the last sentence we used out of many possible... , meaning the first though process to solving any DP problem is to find all the possible breakdowns of the problem. For the given problem, we are trying to find the longest increasing subseqeuence, thus the starting thought process could be to look at all the possible subsequences. Therefore, alongwith optimization problems, DP can be equally useful for other classes of problems where we need to enumerate the possible solutions and pick the subset from enumerations. Well, we think the intro was already too long to get you bored reading this document. So, let's dive into the actual useful content . Solving DP problems boils down to two main aspects of the problem. First, finding a optimal substructure , and second, finding overlapping subproblems . What are these fancy terms? Let's look at them in a little more details in the subsections below:","title":"Dynamic Programming"},{"location":"concepts/dp/#optimal-substructure","text":"To understand optimal substructure, let's first understand substructure. So, let's get out of the jargon of DP: let's say, we want to find the wealthiest person in the world, and also let's say that every city in the world compiles a list of people living in the city and their wealth. So, to find the wealthiest person on the earth, one way could be to collect all these lists of people from every city to create a superlong list of billions of people, and then look for the wealthiest person from the list. The other approach would be to divide the task into several steps ( subproblems ). For example, let's first find the wealthiest person in every city. Then, at country level, let's compile a list of all these city-based weltiest persons, and then find the wealthies person in every country. Then, let's compile another list of these country-level wealthiest people at the world-level, and find the wealthiest person in the world! Well, this example is not a DP problem, but we hope you get some idea on substructure. There are two key concepts in these substructures. 1. The problem has to be broken down into levels 2. The problem defintion at every level should remain the same!!! (the most important theory!) Now coming back to the optimal substructure, the idea here is to extend the concept of same problem definition at every level. So, (generally, an optimization) problem is said to have an optimal substructure property if it can be broken down into subproblems and the final solution of the problem can be derived from the solution of these subproblems (also note that: these subproblems could derive their solutions from their own subproblems, and so on!). In our example above, the worldwide problem was solved by solving the same problem (finding the wealthiest) for countries, and the same problem for a country was solved by solving the same problem for cities in the country. Thus, it exibits the optimal substructure property.","title":"Optimal Substructure"},{"location":"concepts/dp/#overlapping-subproblems","text":"Looking at our example above, one thing we can say is that the optimal substructure is not only true for DP problems (how could finding the wealthiest person in the world be a Dynamic Programming problem!). What makes these problems with the optimal substructures, closer to the DP problems, is their characterstic of Overlapping subproblem . So, what exactly is it? For this, let's extend the above problem of finding the wealthiest person in the world with one unrealistic assumption. Let's say, there are many cities in the world that belong to multiple countries (which is not possible in this divided world, but in our idle world, let's say this is true!). For example, let's say there are three countries A, B, and C . Country A has cities x, y , and z; B has cities y ,p,q; and C has cities x , q ,r,s! Also, let's present the above solution from a different perspective (people call it top-down approach, which we will discuss in more details later!). So, let's say, country A first finds its wealthiest person. For this, it asks its cities x, y , and z to do the same. The cities look at their list and find their wealthiest person and report to the country. Now country B does the same asking its cities y ,p,q. The cities look at their lists and find their wealthies person. City y , although it calculated its wealthiest person already for country A, it does the same process of looking throught the same list again for country B. Similarly, x , and q of country C again repeat the process that they already did for their other countries A, and B respectively. I think you are seeing some pattern here, same subproblem (city) has repeated for multiple countries. So, instead of calculating the wealthiest person for a new country again, these cities could be used their previous calculations that they did for the other country. This is the main power of DP problems. So, the main idea of overlapping subproblem is as follows: 1. Same lower subproblem appears in multiple subproblems.","title":"Overlapping subproblems"},{"location":"concepts/dp/#dp-problem-solving-pipeline","text":"Always try to numericalize the given problem. For example, if the problem involves an array or string, try to present the problem in terms of the index of the element in the array or the index of character in the string. Further, in some cases, even if the problem itself is numerical, rephrasing the problem with different numericalization might render the problem being lot more easy to solve. Next try to reframe the given problem in terms of similar smaller subproblems to generate the state transition equations. The most important practice to think in this way is to try out a lot of recursive problems. Then based on the problem statement, come up with the base cases that have the direct values and do not need to be solved recursively. Be aware of the subproblems that are recurring and find ways to store these values so that any future subproblem that relies on the answer of the previous subproblems can directly use them. We will look into a few problems below and disect them in an attempt to follow through the above DP problem solving pipeline just to have better understanding of it. Let's look at the following string/array based DP problems from Leetcode: 72. Edit Distance 1143. Longest Common Subsequence 300. Longest Increasing Subsequence Starting with 300., the first thing in solving a problem is to read it carefully enough such that we do not miss any detail in the question. Let me rewrite the problem while reading it slowly: We are given an unsorted array of integers. We need to find the length of the longest increasing subsequence. The first thing is to figure out that the question is asking for the longest something, making DP one of the viable approaches to solve the problem. Following the first step of the pipeline, let's first try to numericalize the problem. One approach would be to descibe the given array with two numbers, the indices of the first and the last elements of the array. This way, we can look at the subproblems being the subarrays represented with the indices between the indices of the original problem. I am sure you must have lost my explanation here. So, let's look at an example. If the given array is [10,9,2,5,3,7,101,18], we numericalize the problem as follows: find the length of longest increasing subsequence for the given array between the indices 0 and 7 (inclusive). With this as the main problem, our subproblems might be to find the same thing (length of the longest subsequence for the given array) between indices 1 and 3 or between 2 and 5. Similarly, the subproblems for the one between indices 1 and 3 include the indices betwee 1 and 2 or between 2 and 3 or between 2 and 2, etc. One thing you might have noticed while defining the problem with two indices, we can see that the subproblems are being defined with movements on both the ends. Obviously, a problem with movement on the both ends will be difficult to solve, so let's try to renumericalize the problem with a single movable component. Let's say, we fix the first index at 0 for every possible subproblems, and renumericalize the problem as finding the longest increasing subsequence for the array ending at the index 7. Now, the subproblems would include that ending at index 6, index 5, etc. People like to define these indices in the problems as pointers (which are just a fancy way of saying the same thing).","title":"DP Problem solving pipeline"}]}