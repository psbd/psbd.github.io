# Moving forward vs moving backward in DP problems

Today while looking at the keyboard with leetcode 651. 4 keys keyboard problem, we were having some hard time to relate this problem with any other DP problems, because the solution mechanism is a bit tricky and different. So, we will be discussing about these mechanisms in details in this article. Every DP problem starts with numericalization, and then defining the states. Based on these states, we come up with the state transition equations. So far, in our problems, we defined a final state that provides the answer to the problem at hand, then we looked at the subproblems that we solved in a top-down approach. In the bottom-up approach, we started with the base cases (the smallest subproblems), and moved forward to eventually reach the final state. So, the blueprint for solving these problems was: for top-down approach, we started with the state for the final problem definition and moved recursively downwards into the subproblems, until we reached the base case from which we returned back. Similarly, in the bottom-up approach of the problems, we started with the base cases and slowly built more complex problems from them and moved towards the final problem.
The case with the 4 Keys keyboard is a bit different, because when we define (number of keystrokes (either remaining or pressed), number of items in the screen, number of items in the clipboard), we do not really know the final state we will be in. So, the above approaches are not gonna work. So, for the top down approach, instead of moving from the state definition of the final problem, we need to start from the state definition of the initial state which is known to us (number of keystrokes (either remaining or pressed)=n or 0, items in screen = 0, items in clipboard = 0).
