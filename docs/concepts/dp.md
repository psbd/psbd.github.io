# Dynamic Programming

    keywords: enumeration, optimal substructure, overlapping subproblems, state transition equations
    confusions: top-down approach vs bottom-up approach ==> dynamic programming vs memoization

Based on our understanding, Dynamic Programming (DP) problems are the most asked ones in the technical interivews by the top tech companies.
Thus, we have started our interview preparation journey from the Dynamic Programming concepts. Generally, DP is a concept used for optimization problems (OP).
Well, what are OPs?: Simply presenting, they are the problems that seek to find either maximum or minimum possible value. For example, given an array of numbers, what is the **maximum** possible length of the increasing subsequences that can be created from it? Example: [1,9, 2, 7, 3, 5]. Out of many possible subsequences (eg. 1, 3, 5), the longest increasing subsequence is [1,2,3,5]. If you noticed the last sentence we used **out of many possible...**, meaning the first though process to solving any DP problem is to find all the possible breakdowns of the problem. For the given problem, we are trying to find the longest increasing subseqeuence, thus the starting thought process could be to look at all the possible subsequences. Therefore, alongwith optimization problems, DP can be equally useful for other classes of problems where we need to enumerate the possible solutions and pick the subset from enumerations.

Well, we think the intro was already too long to get you bored reading this document. So, let's dive into the actual _useful content_. Solving DP problems boils down to two main aspects of the problem. First, finding a **optimal substructure**, and second, finding **overlapping subproblems**. What are these fancy terms? Let's look at them in a little more details in the subsections below:

## Optimal Substructure

To understand optimal substructure, let's first understand substructure. So, let's get out of the jargon of DP: let's say, we want to find the wealthiest person in the world, and also let's say that every city in the world compiles a list of people living in the city and their wealth. So, to find the wealthiest person on the earth, one way could be to collect all these lists of people from every city to create a superlong list of billions of people, and then look for the wealthiest person from the list. The other approach would be to divide the task into several steps (_subproblems_). For example, let's first find the wealthiest person in every city. Then, at country level, let's compile a list of all these city-based weltiest persons, and then find the wealthies person in every country. Then, let's compile another list of these country-level wealthiest people at the world-level, and find the wealthiest person in the world! Well, this example is not a DP problem, but we hope you get some idea on substructure. There are two key concepts in these substructures.

    1. The problem has to be broken down into levels
    2. The problem defintion at every level should remain the same!!! (the most important theory!)

Now coming back to the optimal substructure, the idea here is to extend the concept of _same problem definition_ at every level. So, (generally, an optimization) problem is said to have an optimal substructure property if it can be broken down into subproblems and the final solution of the problem can be derived from the solution of these subproblems (also note that: these subproblems could derive their solutions from their own subproblems, and so on!). In our example above, the worldwide problem was solved by solving the _same problem_ (finding the wealthiest) for countries, and the _same problem_ for a country was solved by solving the _same problem_ for cities in the country. Thus, it exibits the optimal substructure property.

## Overlapping subproblems

Looking at our example above, one thing we can say is that the optimal substructure is not only true for DP problems (how could finding the wealthiest person in the world be a Dynamic Programming problem!). What makes these problems with the optimal substructures, closer to the DP problems, is their characterstic of _Overlapping subproblem_. So, what exactly is it? For this, let's extend the above problem of finding the wealthiest person in the world with one unrealistic assumption. Let's say, there are many cities in the world that belong to multiple countries (which is not possible in this divided world, but in our idle world, let's say this is true!). For example, let's say there are three countries **_A, B, and C_**. Country A has cities x,**y**, and z; B has cities **y**,p,q; and C has cities **x**,**q**,r,s! Also, let's present the above solution from a different perspective (people call it top-down approach, which we will discuss in more details later!). So, let's say, country A first finds its wealthiest person. For this, it asks its cities x,**y**, and z to do the same. The cities look at their list and find their wealthiest person and report to the country. Now country B does the same asking its cities **y**,p,q. The cities look at their lists and find their wealthies person. City **y**, although it calculated its wealthiest person already for country A, it does the same process of looking throught the same list again for country B. Similarly, **x**, and **q** of country C again repeat the process that they already did for their other countries A, and B respectively. I think you are seeing some pattern here, same subproblem (city) has repeated for multiple countries. So, instead of calculating the wealthiest person for a new country again, these cities could be used their previous calculations that they did for the other country. This is the main power of DP problems. So, the main idea of overlapping subproblem is as follows:

    1. Same lower subproblem appears in multiple subproblems.

## DP Problem solving pipeline

1. Always try to numericalize the given problem. For example, if the problem involves an array or string, try to present the problem in terms of the index of the element in the array or the index of character in the string. Further, in some cases, even if the problem itself is numerical, rephrasing the problem with different numericalization might render the problem being lot more easy to solve.

2. Next try to reframe the given problem in terms of similar smaller subproblems to generate the state transition equations. The most important practice to think in this way is to try out a lot of recursive problems. While thinking the solution of the problem as the development from the subproblems that have the same definition but involving subparts of the given input, the best practice would be to believe that we already have answers to these subproblems.

3. Then based on the problem statement, come up with the base cases that have the direct values and do not need to be solved recursively.

4. Be aware of the subproblems that are recurring and find ways to store these values so that any future subproblem that relies on the answer of the previous subproblems can directly use them.

We will look into a few problems below and disect them in an attempt to follow through the above DP problem solving pipeline just to have better understanding of it. Let's look at the following string/array based DP problems from Leetcode: 72. Edit Distance 1143. Longest Common Subsequence 300. Longest Increasing Subsequence
Starting with 300., the first thing in solving a problem is to read it carefully enough such that we do not miss any detail in the question. Let me rewrite the problem while reading it slowly: We are given an **unsorted** array of integers. We need to find the **length of the longest** increasing subsequence. The first thing is to figure out that the question is asking for the longest something, making DP one of the viable approaches to solve the problem.

Following the first step of the pipeline, let's first try to numericalize the problem. One approach would be to descibe the given array with two numbers, the indices of the first and the last elements of the array. This way, we can look at the subproblems being the subarrays represented with the indices between the indices of the original problem. I am sure you must have lost my explanation here. So, let's look at an example. If the given array is [10,9,2,5,3,7,101,18], we numericalize the problem as follows: find the length of longest increasing subsequence for the given array between the indices 0 and 7 (inclusive). With this as the main problem, our subproblems might be to find the same thing (length of the longest subsequence for the given array) between indices 1 and 3 or between 2 and 5. Similarly, the subproblems for the one between indices 1 and 3 include the indices betwee 1 and 2 or between 2 and 3 or between 2 and 2, etc. One thing you might have noticed while defining the problem with two indices, we can see that the subproblems are being defined with movements on both the ends. Obviously, a problem with movement on the both ends will be difficult to solve, so let's try to renumericalize the problem with a single movable component, if possible. Let's say, we fix the first index at 0 for every possible subproblems, and renumericalize the problem as finding the longest increasing subsequence for the array upto the index 7. Notice, that I am using upto the index 7, rather than saying ending at index 7.

<!--- This is because our longest subsequence of the entire array might not involve the last element of the array at all. --->

We can compute the value of LIS using the definition as **ending at index 7** as well, but wanted to let you know that different defintion will yield different approaches later in the pipeline, and if we happen to mix them up, we are not going to get the correct answer, so while numericalizing the problem, pay extra attention not to miss out the minute details that you have assumed. Now, the subproblems would include the **longest length of LIS** (notice that I am using the same definition of problem for the subproblems!) upto the index 6, upto the index 5, etc. People like to define these indices in the problems as pointers (which are just a fancy way of saying the same thing).

Now, let's try to rephrase our problem as a development from the subproblems. Like we said above, while looking for the solution for the problem, let's not try to think about solving subproblems from their own subproblems at this point in time. But rather let's believe that there's already solutions to every subproblem of the problem. Once we are able to define the solution completely with the help of subproblems, same solution will apply to the subproblems of each subproblem, and so on. I know it is difficult to understand what I am trying to say here, so let's try to apply this concept for the above question. To find the longest length of LIS for the array upto the index 7, let's believe that we already have LIS for the arrays upto any index before 7. Now, with this assumption of **longest length of LIS** already been computed for lower indices, how can we use these integer values of LISes to find **longest length of LIS** upto index 7? To answer this question, let's look at the fundamental definition of **Increasing** Subsequence before dealing with the longest one. For this, always think in linear steps, because that's how comuters execute your code, right? So, for example, to create a subsequence of length 4, we start with the first element of the sequence. Next, to put the second element to the **Increasing** sequence, we put this second item to the sequence, only if it is larger than the first one. Then for the third element, we put it to the sequence only if it is larger than the second element, and so on. So, with the length of LISes upto any of the array indices before 7 already computed, we would be able to extend the length of any of these subsequences, only if the element in index 7 is larger than the element at the respective index, right? So, let's say we have our longest length of LIS for index 1, 2, and 3 as p, q, and r. So, if we are trying to find LIS of l
...

## States and Choices

Read every question very carefully. Every question will have states. For example, in case of stock buy and sell problem, we are given the prices of stocks on each day in form of an array and our goal is to maximize the profit that we can get. One thing we have to make sure while buying and selling the stocks is that we are not allowed to have hold of any stock before buying a new one. If we have to buy a new stock, we need to check if we have already owned a stock, if so, we need to first sell it, and only than we can buy a new one.

Solving this problem boils down to states, and choices. So, each day we have an option to buy, sell, or remain idle. Meaning, one of our states could be the day where we currently are on, right? And as you might have guessed, our choices in each day is to buy, sell, or remain idle. Now, have we completely defined the problem in terms of states and choices. I think not, we still need to handle the requirement that we can only own a single stock at any instance. Meaning, our choices are constrained. So, to handle the constaints in the choices, we need to define it in terms of other state(s). And I generally call these states as the induced state, the other states that we define directly from the question, I call them direct states.

Also, we need to make sure that our DP solution handles every possible states in the state transition equations. That's for now! We will get into the details of the solution of the stock problems later.
